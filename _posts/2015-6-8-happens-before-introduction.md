---
layout: post
title: 读书笔记：happens-before原则
category: back
description: Java happens-before原则。
tags: [java memory model]
---

如果Java内存模型中，所有的有序性都仅仅靠volite和synchronized来完成，那么有一些操作将会变的非常烦琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“happens-before”的原则。

这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下，两个操作之间是否可能存在冲突的所有问题。

## **定义**

Happens-before原则是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

这个定义不难理解，但它意味着什么呢，可以举个例子来说明，如下代码清单：

<pre class="brush: java">
// 以下操作在线程A中执行
i ＝ 1;
// 以下操作在线程B中执行
j ＝ i;
// 以下操作在线程C中执行
i = 2;
</pre>

假设线程A中的操作“i＝1”先行发生于线程B中的操作“j＝i”，那么可以确定在线程B的操作执行后，变量j的值一定等于1，得出这个结论的依据有两个：

1.  根据先行发生原则，“i＝1的结果可以被观察到”；
2.  线程C还没登场，线程A操作结束之后没有其他线程会修改变量i的值。

现在再考虑线程C，我们依然保持线程A和线程B之间的先行发生关系，而线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那么j的值会是多少呢？

**答案是不确定!**

1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可以不会，这时候线程B就存在度渠道过期数据的风险，不具备多线程安全性。

## **规则**

下面是Java内存模型下一些“天然的”先行发生关系，这是先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作